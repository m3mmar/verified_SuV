(*
 * Documentation
 * -------------
 * First read vf_README.txt
 * Then read the --help of this program.
 * 
 * Build
 * -----
 * Quick run: ocaml str.cma lnxmod_proxy_autogen.ml
 * Compile: ocamlopt -g str.cmxa lnxmod_proxy_autogen.ml -o lnxmod_proxy_autogen
 * Compile with stacktrace for uncaught exceptions:
 *   ocamlopt -g str.cmxa lnxmod_proxy_autogen.ml -o lnxmod_proxy_autogen ; export OCAMLRUNPARAM=b
 *)


(* Let's put all names and naming conventions in a central place *)

  let toolname = "lnxmod_proxy_autogen"

  let module_name inputfile =
    let basename = Filename.basename inputfile in
    Filename.chop_extension basename

  let autogen_modulename inputfile =
    "vf_autogenerated_initexit_proxy_" ^ (module_name inputfile)
  
  (* Without directory. *)
  let autogen_filename_initexit inputfile = 
    (autogen_modulename inputfile) ^ ".c"

  let autogen_filename_vfmanifest inputfile =
    (autogen_modulename inputfile) ^ ".vfmanifest"

  let autogen_full_filename_initexit inputfile =
    let dir = Filename.dirname inputfile in  
    Filename.concat dir (autogen_filename_initexit inputfile)

  let autogen_full_filename_vfmanifest inputfile =
    let dir = Filename.dirname inputfile in  
    Filename.concat dir (autogen_filename_vfmanifest inputfile)

  let init_procedure_name inputfile =
    (module_name inputfile) ^ "_module_init"

  let exit_procedure_name inputfile =
    (module_name inputfile) ^ "_module_exit"

  

(* End naming conventions *)




let print_error error =
  Printf.fprintf stderr "%s\n" error

let exit_with_error () =
  exit 1
;;


let exit_with_error_message error =
  print_error (toolname ^ ": " ^ error);
  exit_with_error ()
;;
  
(* Checks whether the given name does not contain weird characters like "~!@#$%^&*(){}". *)
let has_no_weird_characters name =
  Str.string_match (Str.regexp "^[a-zA-Z_][a-zA-Z_]*$") name 0


let print_help_and_exit () =

  print_string begin
    "Usage: " ^ toolname ^ " FILE\n" ^
    "   or: " ^ toolname ^ " clean FILE\n" ^
    "   or: " ^ toolname ^ " --help\n" ^
    "Autogenerate a .c file and a .vfmanifest for verifying Linux kernel modules.\n\n" ^

    "Do not use this tool directly, it is called automatically by the buildsystem,\n" ^
    "implemented in vf_buildsystem.make.\n\n" ^

    "For a given filename x.c, generate a file `" ^ (autogen_filename_initexit "x.c") ^ "'\n" ^
    "which takes care of the kernel module initialisation and cleanup, using the\n" ^
    "procedures `" ^ (init_procedure_name "x.c") ^ "' and " ^
    "`" ^ (exit_procedure_name "x.c") ^ "', which must be provided by x.c\n" ^
    "(see vf_README.txt for more information about how to write x.c).\n\n" ^
    "Generate a file `" ^ (autogen_filename_vfmanifest "x.c") ^ "' which serves as\n" ^
    "input for verifast.  With this file, verifast can check whether x.c satisfies\n" ^
    "the contract as specified in vf_initexit.h\n\n" ^
    "clean FILE indicates the autogenerated files based on input file FILE should\n" ^
    "be removed.\n\n" ^
    "See vf_README.txt, shipped with the VeriFast Linux Kernel Module Verification\n" ^
    "Kit, for more documentation.\n"
  end
  
;;

(* Check whether the given input filename matches our conventions. *)
let check_filename file = 
  let basename = Filename.basename file in
  
  if (not (Filename.check_suffix file ".c")) && (not (Filename.check_suffix file ".C")) then begin
    exit_with_error_message ("file `" ^ file ^ "' has wrong extension, should be `.c'.")
  end ;

  if not (has_no_weird_characters (module_name file)) then begin
    exit_with_error_message("file `" ^ basename ^ "' has invalid name, " ^
      "do not use characters like '#'.")
  end ;
  
;;

(* Clean up (remove) the files we have autogenerated for the given file.
 * Can also be used in case of unexpected errors to make sure we do not leave invalid mess. *)
let clean_autogen_files_for inputfile =
  
  check_filename inputfile;
  
  let file_vfmanifest = autogen_full_filename_vfmanifest inputfile in
  let file_initexit = autogen_full_filename_initexit inputfile in
  
  try
    (* We also have to clean up in case something goes wrong (e.g. disk full).
     * The worst thing we can do, is leave an empty vfmanifest file!
     * So we do this file first, and the other file later.
     *)
    if Sys.file_exists file_vfmanifest then begin
      Sys.remove file_vfmanifest
    end ;
    if Sys.file_exists file_initexit then begin
      Sys.remove file_initexit
    end
  with
    (* Undocumented exception: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html (retreieved 2010-10-30) *)
    (* The content of the Sys_error message is also unspecified, it currently seems to include the
     * filename, so we do not print the filename ourself and hope the undocumented implementation doesn't change. *)
    Sys_error msg -> exit_with_error_message ("Cannot remove file: " ^ msg)
  

let autogenerate_initexit inputfile =

  try 
    let channel = open_out (autogen_full_filename_initexit inputfile) in
    
    Printf.fprintf channel "#include <linux/init.h>\n";
    Printf.fprintf channel "#include <linux/errno.h>\n";
    Printf.fprintf channel "\n";
    Printf.fprintf channel "/* \n";
    Printf.fprintf channel " * This file is automatically generated from `%s'.\n" (Filename.basename inputfile);
    Printf.fprintf channel " * by %s.  You should not edit this file, it should\n" toolname;
    Printf.fprintf channel " * be autogenerated every time the kernel module is build. \n";
    Printf.fprintf channel " * See vf_README.txt for information.\n";
    Printf.fprintf channel " */\n";
    Printf.fprintf channel "\n";
    Printf.fprintf channel "/* \n";
    Printf.fprintf channel " * We depend on these two procedures, the user of the vf_api must\n";
    Printf.fprintf channel " * provide it to us\n";
    Printf.fprintf channel " */\n";
    Printf.fprintf channel "int %s();\n" (init_procedure_name inputfile);
    Printf.fprintf channel "void %s();\n" (exit_procedure_name inputfile);
    Printf.fprintf channel "\n";
    Printf.fprintf channel "\n";
    (* Use tabs instead of spaces in the generated file to conform Linux' coding style. *)
    Printf.fprintf channel "static int __init vf_module_init()\n";
    Printf.fprintf channel "{\n";
    Printf.fprintf channel "	if (%s() == 0){\n" (init_procedure_name inputfile);
    Printf.fprintf channel "		return 0;\n";
    Printf.fprintf channel "	}else{\n";
    Printf.fprintf channel "		return -ENOMEM;;\n";
    Printf.fprintf channel "	}\n";
    Printf.fprintf channel "}\n";
    Printf.fprintf channel "\n";
    Printf.fprintf channel "static void __exit vf_module_exit()\n";
    Printf.fprintf channel "{\n";
    Printf.fprintf channel "	%s();\n" (exit_procedure_name inputfile);
    Printf.fprintf channel "}\n";
    Printf.fprintf channel "\n";
    Printf.fprintf channel "module_init(vf_module_init)\n";
    Printf.fprintf channel "module_exit(vf_module_exit)\n";
    close_out channel
  with
    Sys_error msg -> 
      print_error ("Error while writing file: " ^ msg);
      clean_autogen_files_for inputfile;
      exit_with_error ()

(* Create the vfmanifest file.
 * This autogenerated .vfmanifest file states the requirements of the
 * autogenerated .c file.  These requirements are that the kernel developer must
 * provide the init and exit function, and that these functions
 * are comform the contract as specified in vf_initexit.h.
 *)
let autogenerate_vfmanifest inputfile =
  
  try
    let channel = open_out (autogen_full_filename_vfmanifest inputfile) in
  
    Printf.fprintf channel ".requires ./vf_initexit.h#%s : module_setup_t(%s,%s)\n"
      (init_procedure_name inputfile) (module_name inputfile) (exit_procedure_name inputfile);
    Printf.fprintf channel ".produces module %s\n" (autogen_modulename inputfile);
  
    close_out channel
  with
    Sys_error msg -> 
      print_error ("Error while writing file: " ^ msg);
      (* We do not want to pass an incomplete or even empty file to verifast,
       * since verification will then be incorrect!
       * So we make sure we clean our mess (to prevent verifast from reading it)
       * and exit with an error code (such that make will see something is wrong)
       *)
      clean_autogen_files_for inputfile;
      exit_with_error ()
  
(* Autogenerate files, but do not check input validity. *)
let do_autogenerate inputfile =
  autogenerate_initexit inputfile;
  autogenerate_vfmanifest inputfile
;;

(* Do all the file-autogenerate things this tool is designed for. *)
let process_file file =
  check_filename file;
  (* We do not check if the file actually exists.
   * That's no problem, verifast does all the checking. *)
  do_autogenerate file
;;

(* Parse commandline arguments and launch execution. *)
let main () =
  (* If you change this, also change the output of --help. *)
  match Sys.argv with
  | ( [|_ ; "-h"|] | [|_ ; "--help"|] ) -> print_help_and_exit ()
  | [| _ ; "clean" ; file|] -> clean_autogen_files_for file
  | [| _ ; "clean" |] -> exit_with_error_message ("clean: missing input file argument.  Try `" ^ toolname ^ " --help' for more information.")
  | [| _ ; file |] -> process_file file
  | _ -> exit_with_error_message ("Invalid arguments.  Try `" ^ toolname ^ " --help' for more information.")
;;

main ()

